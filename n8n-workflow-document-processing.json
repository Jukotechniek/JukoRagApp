{
  "name": "Document Processing for RAG",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "process-document",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [250, 300],
      "webhookId": "process-document"
    },
    {
      "parameters": {
        "jsCode": "// Split text into chunks with overlap\nfunction splitIntoChunks(text, maxLength = 1000, overlap = 200) {\n  const chunks = [];\n  let startIndex = 0;\n  let chunkIndex = 0;\n\n  while (startIndex < text.length) {\n    let endIndex = Math.min(startIndex + maxLength, text.length);\n\n    // Try to break at sentence boundary\n    if (endIndex < text.length) {\n      const lastPeriod = text.lastIndexOf('.', endIndex);\n      const lastNewline = text.lastIndexOf('\\n', endIndex);\n      const breakPoint = Math.max(lastPeriod, lastNewline);\n\n      if (breakPoint > startIndex + maxLength * 0.5) {\n        endIndex = breakPoint + 1;\n      }\n    }\n\n    const chunkText = text.slice(startIndex, endIndex).trim();\n\n    if (chunkText.length > 0) {\n      chunks.push({\n        text: chunkText,\n        index: chunkIndex,\n        startChar: startIndex,\n        endChar: endIndex\n      });\n      chunkIndex++;\n    }\n\n    startIndex = endIndex - overlap;\n    if (startIndex <= 0) startIndex = endIndex;\n  }\n\n  return chunks;\n}\n\nconst items = $input.all();\nconst result = [];\n\nfor (const item of items) {\n  const { documentId, content, organizationId } = item.json;\n  \n  if (!content || content.trim().length === 0) {\n    result.push({\n      json: {\n        error: 'Empty content',\n        documentId,\n        organizationId\n      }\n    });\n    continue;\n  }\n\n  const chunks = splitIntoChunks(content);\n  \n  result.push({\n    json: {\n      documentId,\n      organizationId,\n      chunks: chunks.map((chunk, idx) => ({\n        text: chunk.text,\n        index: chunk.index,\n        metadata: {\n          chunk_index: chunk.index,\n          startChar: chunk.startChar,\n          endChar: chunk.endChar\n        }\n      })),\n      totalChunks: chunks.length\n    }\n  });\n}\n\nreturn result;"
      },
      "id": "chunk-text",
      "name": "Chunk Text",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [450, 300]
    },
    {
      "parameters": {
        "jsCode": "// Split chunks into batches for OpenAI API\nconst items = $input.all();\nconst result = [];\n\nfor (const item of items) {\n  const { documentId, organizationId, chunks } = item.json;\n  const batchSize = 10; // Small batches to avoid memory issues\n  \n  for (let i = 0; i < chunks.length; i += batchSize) {\n    const batch = chunks.slice(i, i + batchSize);\n    \n    result.push({\n      json: {\n        documentId,\n        organizationId,\n        batchIndex: Math.floor(i / batchSize),\n        batch: batch.map(chunk => chunk.text),\n        chunkMetadata: batch.map(chunk => chunk.metadata)\n      }\n    });\n  }\n}\n\nreturn result;"
      },
      "id": "create-batches",
      "name": "Create Batches",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [650, 300]
    },
    {
      "parameters": {
        "resource": "embedding",
        "operation": "create",
        "model": "text-embedding-3-small",
        "dimensions": 1536,
        "text": "={{ $json.batch }}",
        "options": {}
      },
      "id": "openai-embeddings",
      "name": "Generate Embeddings",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [850, 300],
      "credentials": {
        "openAiApi": {
          "id": "openai-credentials",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Combine embeddings with metadata\nconst items = $input.all();\nconst result = [];\n\nfor (const item of items) {\n  const { documentId, organizationId, batchIndex, chunkMetadata } = item.json;\n  const embeddings = item.json.data || [];\n  \n  const sections = embeddings.map((embedding, idx) => ({\n    document_id: documentId,\n    content: chunkMetadata[idx] ? chunkMetadata[idx].text || '' : '',\n    embedding: embedding.embedding,\n    metadata: chunkMetadata[idx] || {}\n  }));\n  \n  result.push({\n    json: {\n      documentId,\n      organizationId,\n      batchIndex,\n      sections\n    }\n  });\n}\n\nreturn result;"
      },
      "id": "combine-embeddings",
      "name": "Combine Embeddings",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "operation": "insert",
        "schema": "public",
        "table": "document_sections",
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "document_id": "={{ $json.sections[0].document_id }}",
            "content": "={{ $json.sections[0].content }}",
            "embedding": "={{ $json.sections[0].embedding }}",
            "metadata": "={{ $json.sections[0].metadata }}"
          }
        },
        "options": {}
      },
      "id": "insert-sections",
      "name": "Insert to Supabase",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [1250, 300],
      "credentials": {
        "postgres": {
          "id": "supabase-postgres",
          "name": "Supabase Postgres"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { \"success\": true, \"chunksProcessed\": $json.totalChunks || 0, \"message\": \"Document processed successfully\" } }}"
      },
      "id": "respond-success",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1450, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { \"success\": false, \"error\": $json.error || \"Unknown error\" } }}",
        "options": {
          "responseCode": 500
        }
      },
      "id": "respond-error",
      "name": "Respond Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [650, 500]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Chunk Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chunk Text": {
      "main": [
        [
          {
            "node": "Create Batches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Batches": {
      "main": [
        [
          {
            "node": "Generate Embeddings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Embeddings": {
      "main": [
        [
          {
            "node": "Combine Embeddings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine Embeddings": {
      "main": [
        [
          {
            "node": "Insert to Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert to Supabase": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 1,
  "updatedAt": "2025-12-17T19:00:00.000Z",
  "versionId": "1"
}





